# pandas 去重计数
> pd.series.unique

# pandas 判断字段是否为数值型、字符型
> np.issubdtype

df = pd.DataFrame({'A': [1, 2, 3], 'B': [1.0, 2.0, 3.0], 
                   'C': [1j, 2j, 3j], 'D': ['a', 'b', 'c']})

np.issubdtype(df['A'].dtype, np.number)

df.select_dtypes(include=[np.number])



# pandas 组内

## 排序

[组内排序](https://zhuanlan.zhihu.com/p/30277559)

```python
import pandas as pd

df = pd.DataFrame([['A',1],['A',3],['A',2],['B',5],['B',9]], columns = ['name','score'])
print(df)

# 先分组再排序
print(df.groupby('name', as_index=False).apply(lambda x: x.sort_values('score', ascending=False)))

# 先排序再分组，直接排序就好了
```

## 组内排序，并加上序号

1. [cumcount](http://www.imooc.com/wenda/detail/566046)
2. [groupby+rank](https://blog.csdn.net/u010652755/article/details/90760692)

```python
import pandas as pd

df = pd.DataFrame([['A',1],['A',3],['A',2],['B',5],['B',9]], columns = ['name','score'])

# 1. cumcount
df.sort_values(by=["score"], inplace=True)
df['seq'] = df.groupby(['name']).cumcount() + 1

# 2. groupby + rank
df["seq2"] = df["score"].groupby(df["name"]).rank(ascending=True, method="min")
```

## 组内求和

```python
import pandas as pd

df = pd.DataFrame({'name':['Jack','Alex','Bob','Nancy','Mary','Alice','Jerry','Wolf'],
              'course':['Chinese','Math','Math','Chinese','Math','English','Chinese','English'],
              'grade':[1,1,2,2,2,2,3,3],
              'score':[85,95,91,78,89,60,87,79]})

# 仅用groupby("name")统计各学生 语文、数据、英语的成绩
不必
```

## 组内累增

```python
import pandas as pd

df = pd.DataFrame({
        "name":["A", "B", "A", "C", "B"]
        , "gain1":[1, 3, 2, 3, 2]
        , "gain2":[2, 5, 9, 9, 5]
        })
df.sort_values(by=["name"], inplace=True)

df[["gain1_cum", "gain2_cum"]] = df.groupby("name")[["gain1", "gain2"]].apply(lambda x:x.cumsum())
```



# python 循环日期

```
import datetime
def main():
    begin = datetime.date(2014,6,1)
    end = datetime.date(2014,6,7)
for i in range((end - begin).days+1):
    day = begin + datetime.timedelta(days=i)
    print str(day)
if __name__ == '__main__':
    main()

```

```
# 方式2

import datatime
from dateutil.parser import parse

def int2datatime(integer):
    return parse(str(integer))

start_date = 20180525 #20190525
end_date   = 20190731

for n in range((int2datatime(end_date)-int2datatime(start_date)).days):
#        n=1
        dt     = int2datatime(start_date)+datetime.timedelta(n)
        dt_cur = dt.strftime("%Y%m%d")
#        dt_pre = int((dt + datetime.timedelta(-1)).strftime("%Y%m%d"))
        
        print(dt_cur)
```

# pandas 窗函数
1. [pandas窗函数](https://www.cnblogs.com/jingsupo/p/python-pandas-rolling.html)
```
import pandas as pd
import numpy as np

df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]})
df["rolling"] = df["B"].rolling(2).sum()
df


df2 = pd.DataFrame({"A":[1,2,3,4,5,6,7], "B":[1,3,2,6,2,5,3]})
df2["roll_b"] = df2["B"].rolling(window=3).mean()
df2

```

# pandas 找出最大行下标
df.values.argmax(axis=1) # axis=1为行，axis=0， 为列